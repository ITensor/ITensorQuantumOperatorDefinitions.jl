var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ITensorQuantumOperatorDefinitions]","category":"page"},{"location":"reference/#ITensorQuantumOperatorDefinitions.OpName-Tuple{AbstractString}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.OpName","text":"OpName is a parameterized type which allows making strings into Julia types for the purpose of representing operator names. The main use of OpName is overloading the op! method which generates operators for indices with certain tags such as \"S=1/2\".\n\nTo make a OpName type, you can use the string macro notation: OpName\"MyTag\".\n\nTo make an OpName value or object, you can use the notation: OpName(\"myop\")\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.SiteType-Tuple{AbstractString}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.SiteType","text":"SiteType is a parameterized type which allows making Index tags into Julia types. Use cases include overloading functions such as op, siteinds, and state which generate custom operators, Index arrays, and IndexVals associated with Index objects having a certain tag.\n\nTo make a SiteType type, you can use the string macro notation: SiteType\"MyTag\"\n\nTo make a SiteType value or object, you can use the notation: SiteType(\"MyTag\")\n\nThere are currently a few built-in site types recognized by jl. The system is easily extensible by users. To add new operators to an existing site type, or to create new site types, you can follow the instructions here.\n\nThe current built-in site types are:\n\nSiteType\"S=1/2\" (or SiteType\"S=½\")\nSiteType\"S=1\"\nSiteType\"Qubit\"\nSiteType\"Qudit\"\nSiteType\"Boson\"\nSiteType\"Fermion\"\nSiteType\"tJ\"\nSiteType\"Electron\"\n\nExamples\n\nTags on indices get turned into SiteTypes internally, and then we search for overloads of functions like op and siteind. For example:\n\njulia> s = siteind(\"S=1/2\")\n(dim=2|id=862|\"S=1/2,Site\")\n\njulia> @show op(\"Sz\", s);\nop(s, \"Sz\") = ITensor ord=2\nDim 1: (dim=2|id=862|\"S=1/2,Site\")'\nDim 2: (dim=2|id=862|\"S=1/2,Site\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 0.5   0.0\n 0.0  -0.5\n\njulia> @show op(\"Sx\", s);\nop(s, \"Sx\") = ITensor ord=2\nDim 1: (dim=2|id=862|\"S=1/2,Site\")'\nDim 2: (dim=2|id=862|\"S=1/2,Site\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 0.0  0.5\n 0.5  0.0\n\njulia> @show op(\"Sy\", s);\nop(s, \"Sy\") = ITensor ord=2\nDim 1: (dim=2|id=862|\"S=1/2,Site\")'\nDim 2: (dim=2|id=862|\"S=1/2,Site\")\nNDTensors.Dense{Complex{Float64},Array{Complex{Float64},1}}\n 2×2\n 0.0 + 0.0im  -0.0 - 0.5im\n 0.0 + 0.5im   0.0 + 0.0im\n\njulia> s = siteind(\"Electron\")\n(dim=4|id=734|\"Electron,Site\")\n\njulia> @show op(\"Nup\", s);\nop(s, \"Nup\") = ITensor ord=2\nDim 1: (dim=4|id=734|\"Electron,Site\")'\nDim 2: (dim=4|id=734|\"Electron,Site\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 4×4\n 0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n\nMany operators are available, for example:\n\nSiteType\"S=1/2\": \"Sz\", \"Sx\", \"Sy\", \"S+\", \"S-\", ...\nSiteType\"Electron\": \"Nup\", \"Ndn\", \"Nupdn\", \"Ntot\", \"Cup\",  \"Cdagup\", \"Cdn\", \"Cdagdn\", \"Sz\", \"Sx\", \"Sy\", \"S+\", \"S-\", ...\n...\n\nYou can view the source code for the internal SiteType definitions and operators that are defined here.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.op-Tuple{AbstractArray, Vararg{ITensorBase.Index}}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.op","text":"op(X::AbstractArray, s::Index...)\nop(M::Matrix, s::Index...)\n\nGiven a matrix M and a set of indices s,t,... return an operator ITensor with matrix elements given by M and indices s, s', t, t'\n\nExample\n\njulia> s = siteind(\"S=1/2\")\n(dim=2|id=575|\"S=1/2,Site\")\n\njulia> Sz = op([1/2 0; 0 -1/2],s)\nITensor ord=2 (dim=2|id=575|\"S=1/2,Site\")' (dim=2|id=575|\"S=1/2,Site\")\nNDTensors.Dense{Float64, Vector{Float64}}\n\njulia> @show Sz\nSz = ITensor ord=2\nDim 1: (dim=2|id=575|\"S=1/2,Site\")'\nDim 2: (dim=2|id=575|\"S=1/2,Site\")\nNDTensors.Dense{Float64, Vector{Float64}}\n 2×2\n 0.5   0.0\n 0.0  -0.5\nITensor ord=2 (dim=2|id=575|\"S=1/2,Site\")' (dim=2|id=575|\"S=1/2,Site\")\nNDTensors.Dense{Float64, Vector{Float64}}\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.op-Tuple{AbstractString, Vararg{ITensorBase.Index}}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.op","text":"op(opname::String, s::Index; kwargs...)\n\nReturn an ITensor corresponding to the operator named opname for the Index s. The operator is constructed by calling an overload of either the op or op! methods which take a SiteType argument that corresponds to one of the tags of the Index s and an OpName\"opname\" argument that corresponds to the input operator name.\n\nOperator names can be combined using the \"*\" symbol, for example \"S+*S-\" or \"Sz*Sz*Sz\". The result is an ITensor made by forming each operator then contracting them together in a way corresponding to the usual operator product or matrix multiplication.\n\nThe op system is used by the OpSum system to convert operator names into ITensors, and can be used directly such as for applying operators to MPS.\n\nExample\n\ns = Index(2, \"Site,S=1/2\")\nSz = op(\"Sz\", s)\n\nTo see all of the operator names defined for the site types included with ITensor, please view the source code for each site type. Note that some site types such as \"S=1/2\" and \"Qubit\" are aliases for each other and share operator definitions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.op-Union{Tuple{N}, Tuple{Any, Vector{<:ITensorBase.Index}, NTuple{N, Integer}}} where N","page":"Reference","title":"ITensorQuantumOperatorDefinitions.op","text":"op(opname::String,sites::Vector{<:Index},n::Int; kwargs...)\n\nReturn an ITensor corresponding to the operator named opname for the n'th Index in the array sites.\n\nExample\n\ns = siteinds(\"S=1/2\", 4)\nSz2 = op(\"Sz\", s, 2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.ops-Tuple{Vector{<:ITensorBase.Index}, AbstractArray}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.ops","text":"ops(s::Vector{<:Index}, os::Vector)\nops(os::Vector, s::Vector{<:Index})\n\nGiven a list of operators, create ITensors using the collection of indices.\n\nExamples\n\ns = siteinds(\"Qubit\", 4)\nos = [(\"H\", 1), (\"X\", 2), (\"CX\", 2, 4)]\n# gates = ops(s, os)\ngates = ops(os, s)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.siteinds-Tuple{Function, Integer}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.siteinds","text":"siteinds(f::Function, N::Integer; kwargs...)\n\nCreate an array of N physical site indices where the site type at site n is given by f(n) (f should return a string).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.siteinds-Tuple{Integer, Integer}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.siteinds","text":"siteinds(d::Integer, N::Integer; kwargs...)\n\nCreate an array of N site indices, each of dimension d.\n\nKeywords\n\naddtags::String: additional tags to be added to all indices\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.siteinds-Tuple{String, Integer}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.siteinds","text":"siteinds(tag::String, N::Integer; kwargs...)\n\nCreate an array of N physical site indices of type tag. Keyword arguments can be used to specify quantum number conservation, see the space function corresponding to the site type tag for supported keyword arguments.\n\nExample\n\nN = 10\ns = siteinds(\"S=1/2\", N; conserve_qns=true)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.space-Tuple{ITensorQuantumOperatorDefinitions.SiteType{:Boson}}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.space","text":"space(::SiteType\"Boson\";\n      dim = 2,\n      conserve_qns = false,\n      conserve_number = false,\n      qnname_number = \"Number\")\n\nCreate the Hilbert space for a site of type \"Boson\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.space-Tuple{ITensorQuantumOperatorDefinitions.SiteType{:Electron}}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.space","text":"space(::SiteType\"Electron\";\n      conserve_qns = false,\n      conserve_sz = conserve_qns,\n      conserve_nf = conserve_qns,\n      conserve_nfparity = conserve_qns,\n      qnname_sz = \"Sz\",\n      qnname_nf = \"Nf\",\n      qnname_nfparity = \"NfParity\")\n\nCreate the Hilbert space for a site of type \"Electron\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.space-Tuple{ITensorQuantumOperatorDefinitions.SiteType{:Fermion}}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.space","text":"space(::SiteType\"Fermion\";\n      conserve_qns=false,\n      conserve_nf=conserve_qns,\n      conserve_nfparity=conserve_qns,\n      qnname_nf = \"Nf\",\n      qnname_nfparity = \"NfParity\",\n      qnname_sz = \"Sz\",\n      conserve_sz = false)\n\nCreate the Hilbert space for a site of type \"Fermion\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.space-Tuple{ITensorQuantumOperatorDefinitions.SiteType{:Qubit}}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.space","text":"space(::SiteType\"Qubit\";\n      conserve_qns = false,\n      conserve_parity = conserve_qns,\n      conserve_number = false,\n      qnname_parity = \"Parity\",\n      qnname_number = \"Number\")\n\nCreate the Hilbert space for a site of type \"Qubit\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.space-Tuple{ITensorQuantumOperatorDefinitions.SiteType{:Qudit}}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.space","text":"space(::SiteType\"Qudit\";\n      dim = 2,\n      conserve_qns = false,\n      conserve_number = false,\n      qnname_number = \"Number\")\n\nCreate the Hilbert space for a site of type \"Qudit\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.space-Tuple{ITensorQuantumOperatorDefinitions.SiteType{:tJ}}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.space","text":"space(::SiteType\"tJ\";\n      conserve_qns = false,\n      conserve_sz = conserve_qns,\n      conserve_nf = conserve_qns,\n      conserve_nfparity = conserve_qns,\n      qnname_sz = \"Sz\",\n      qnname_nf = \"Nf\",\n      qnname_nfparity = \"NfParity\")\n\nCreate the Hilbert space for a site of type \"tJ\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.space-Tuple{ITensorQuantumOperatorDefinitions.SiteType{Symbol(\"S=1\")}}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.space","text":"space(::SiteType\"S=1\";\n      conserve_qns = false,\n      conserve_sz = conserve_qns,\n      qnname_sz = \"Sz\")\n\nCreate the Hilbert space for a site of type \"S=1\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.space-Tuple{ITensorQuantumOperatorDefinitions.SiteType{Symbol(\"S=1/2\")}}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.space","text":"space(::SiteType\"S=1/2\";\n      conserve_qns = false,\n      conserve_sz = conserve_qns,\n      conserve_szparity = false,\n      qnname_sz = \"Sz\",\n      qnname_szparity = \"SzParity\")\n\nCreate the Hilbert space for a site of type \"S=1/2\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.state-Tuple{ITensorBase.Index, AbstractString}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.state","text":"state(s::Index, name::String; kwargs...)\n\nReturn an ITensor corresponding to the state named name for the Index s. The returned ITensor will have s as its only index.\n\nThe terminology here is based on the idea of a single-site state or wavefunction in physics.\n\nThe state function is implemented for various Index tags by overloading either the state or state! methods which take a SiteType argument corresponding to one of the tags of the Index s and an StateName\"name\" argument that corresponds to the input state name.\n\nThe state system is used by the MPS type to construct product-state MPS and for other purposes.\n\nExample\n\ns = Index(2, \"Site,S=1/2\")\nsup = state(s,\"Up\")\nsdn = state(s,\"Dn\")\nsxp = state(s,\"X+\")\nsxm = state(s,\"X-\")\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorQuantumOperatorDefinitions.val-Tuple{ITensorBase.Index, AbstractString}","page":"Reference","title":"ITensorQuantumOperatorDefinitions.val","text":"val(s::Index, name::String)\n\nReturn an integer corresponding to the name of a certain value the Index s can take. In other words, the val function maps strings to specific integer values within the range 1:dim(s).\n\nThe val function is implemented for various Index tags by overloading methods named val which take a SiteType argument corresponding to one of the tags of the Index s and an ValName\"name\" argument that corresponds to the input name.\n\nExample\n\ns = Index(2, \"Site,S=1/2\")\nval(s,\"Up\") == 1\nval(s,\"Dn\") == 2\n\ns = Index(2, \"Site,Fermion\")\nval(s,\"Emp\") == 1\nval(s,\"Occ\") == 2\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"../../examples/README.jl\"","category":"page"},{"location":"#ITensorQuantumOperatorDefinitions.jl","page":"Home","title":"ITensorQuantumOperatorDefinitions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: Aqua)","category":"page"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package resides in the ITensor/ITensorRegistry local registry. In order to install, simply add that registry through your package manager. This step is only required once.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the package can be added as usual through the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.add(\"ITensorQuantumOperatorDefinitions\")","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using ITensorBase: ITensor, Index, tags\nusing ITensorQuantumOperatorDefinitions:\n  OpName, SiteType, StateName, ValName, op, siteind, siteinds, state, val\nusing Test: @test","category":"page"},{"location":"","page":"Home","title":"Home","text":"States and operators as Julia arrays","category":"page"},{"location":"","page":"Home","title":"Home","text":"@test val(ValName(\"Up\"), SiteType(\"S=1/2\")) == 1\n@test val(ValName(\"Dn\"), SiteType(\"S=1/2\")) == 2\n@test state(StateName(\"Up\"), SiteType(\"S=1/2\")) == [1, 0]\n@test state(StateName(\"Dn\"), SiteType(\"S=1/2\")) == [0, 1]\n@test op(OpName(\"X\"), SiteType(\"S=1/2\")) == [0 1; 1 0]\n@test op(OpName(\"Z\"), SiteType(\"S=1/2\")) == [1 0; 0 -1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Index constructors","category":"page"},{"location":"","page":"Home","title":"Home","text":"@test siteind(\"S=1/2\") isa Index\n@test Int(length(siteind(\"S=1/2\"))) == 2\n@test \"S=1/2\" in tags(siteind(\"S=1/2\"))\n@test siteinds(\"S=1/2\", 4) isa Vector{<:Index}\n@test length(siteinds(\"S=1/2\", 4)) == 4\n@test all(s -> \"S=1/2\" in tags(s), siteinds(\"S=1/2\", 4))","category":"page"},{"location":"","page":"Home","title":"Home","text":"States and operators as ITensors","category":"page"},{"location":"","page":"Home","title":"Home","text":"s = Index(2, \"S=1/2\")\n@test val(s, \"Up\") == 1\n@test val(s, \"Dn\") == 2\n@test state(\"Up\", s) == ITensor([1, 0], (s,))\n@test state(\"Dn\", s) == ITensor([0, 1], (s,))\n@test op(\"X\", s) == ITensor([0 1; 1 0], (s', s))\n@test op(\"Z\", s) == ITensor([1 0; 0 -1], (s', s))","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This page was generated using Literate.jl.","category":"page"}]
}
